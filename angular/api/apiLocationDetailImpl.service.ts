/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { ByteArrayResource } from '../model/byteArrayResource';
import { LocationForTable } from '../model/locationForTable';
import { LocationParent } from '../model/locationParent';
import { LocationProvidingInfo } from '../model/locationProvidingInfo';
import { PageLocationForTable } from '../model/pageLocationForTable';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ApiLocationDetailImplService {

    protected basePath = 'https://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * byUser
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public byUserUsingGET(observe?: 'body', reportProgress?: boolean): Observable<Array<LocationForTable>>;
    public byUserUsingGET(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<LocationForTable>>>;
    public byUserUsingGET(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<LocationForTable>>>;
    public byUserUsingGET(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<LocationForTable>>(`${this.basePath}/api/detail-locations/by-user`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * deleteById
     * 
     * @param id id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteByIdUsingDELETE(id: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteByIdUsingDELETE(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteByIdUsingDELETE(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteByIdUsingDELETE(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteByIdUsingDELETE.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/api/detail-locations/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * exportExcel
     * 
     * @param locationIds locationIds
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public exportExcelUsingPOST(locationIds: Array<number>, observe?: 'body', reportProgress?: boolean): Observable<ByteArrayResource>;
    public exportExcelUsingPOST(locationIds: Array<number>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ByteArrayResource>>;
    public exportExcelUsingPOST(locationIds: Array<number>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ByteArrayResource>>;
    public exportExcelUsingPOST(locationIds: Array<number>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (locationIds === null || locationIds === undefined) {
            throw new Error('Required parameter locationIds was null or undefined when calling exportExcelUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ByteArrayResource>(`${this.basePath}/api/detail-locations/export-excel`,
            locationIds,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getList
     * 
     * @param cellularOperators cellular-operators
     * @param internetOperators internet-operators
     * @param internetType internet-type
     * @param isLogicalOr is-logical-or
     * @param location location
     * @param mobileType mobile-type
     * @param offset 
     * @param paged 
     * @param pageNumber 
     * @param pageSize 
     * @param parent parent
     * @param sortSorted 
     * @param sortUnsorted 
     * @param unpaged 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getListUsingGET(cellularOperators?: Array<number>, internetOperators?: Array<number>, internetType?: Array<number>, isLogicalOr?: boolean, location?: string, mobileType?: Array<number>, offset?: number, paged?: boolean, pageNumber?: number, pageSize?: number, parent?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'body', reportProgress?: boolean): Observable<PageLocationForTable>;
    public getListUsingGET(cellularOperators?: Array<number>, internetOperators?: Array<number>, internetType?: Array<number>, isLogicalOr?: boolean, location?: string, mobileType?: Array<number>, offset?: number, paged?: boolean, pageNumber?: number, pageSize?: number, parent?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageLocationForTable>>;
    public getListUsingGET(cellularOperators?: Array<number>, internetOperators?: Array<number>, internetType?: Array<number>, isLogicalOr?: boolean, location?: string, mobileType?: Array<number>, offset?: number, paged?: boolean, pageNumber?: number, pageSize?: number, parent?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageLocationForTable>>;
    public getListUsingGET(cellularOperators?: Array<number>, internetOperators?: Array<number>, internetType?: Array<number>, isLogicalOr?: boolean, location?: string, mobileType?: Array<number>, offset?: number, paged?: boolean, pageNumber?: number, pageSize?: number, parent?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (cellularOperators) {
            cellularOperators.forEach((element) => {
                queryParameters = queryParameters.append('cellular-operators', <any>element);
            })
        }
        if (internetOperators) {
            internetOperators.forEach((element) => {
                queryParameters = queryParameters.append('internet-operators', <any>element);
            })
        }
        if (internetType) {
            internetType.forEach((element) => {
                queryParameters = queryParameters.append('internet-type', <any>element);
            })
        }
        if (isLogicalOr !== undefined && isLogicalOr !== null) {
            queryParameters = queryParameters.set('is-logical-or', <any>isLogicalOr);
        }
        if (location !== undefined && location !== null) {
            queryParameters = queryParameters.set('location', <any>location);
        }
        if (mobileType) {
            mobileType.forEach((element) => {
                queryParameters = queryParameters.append('mobile-type', <any>element);
            })
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (paged !== undefined && paged !== null) {
            queryParameters = queryParameters.set('paged', <any>paged);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (parent !== undefined && parent !== null) {
            queryParameters = queryParameters.set('parent', <any>parent);
        }
        if (sortSorted !== undefined && sortSorted !== null) {
            queryParameters = queryParameters.set('sort.sorted', <any>sortSorted);
        }
        if (sortUnsorted !== undefined && sortUnsorted !== null) {
            queryParameters = queryParameters.set('sort.unsorted', <any>sortUnsorted);
        }
        if (unpaged !== undefined && unpaged !== null) {
            queryParameters = queryParameters.set('unpaged', <any>unpaged);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageLocationForTable>(`${this.basePath}/api/detail-locations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getOne
     * 
     * @param id id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOneUsingGET1(id: number, observe?: 'body', reportProgress?: boolean): Observable<LocationForTable>;
    public getOneUsingGET1(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LocationForTable>>;
    public getOneUsingGET1(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LocationForTable>>;
    public getOneUsingGET1(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getOneUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<LocationForTable>(`${this.basePath}/api/detail-locations/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * govProgramYears
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public govProgramYearsUsingGET(observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public govProgramYearsUsingGET(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public govProgramYearsUsingGET(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public govProgramYearsUsingGET(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<number>>(`${this.basePath}/api/detail-locations/gov-years`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * locationProvidingInfo
     * 
     * @param locationId locationId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public locationProvidingInfoUsingGET(locationId: number, observe?: 'body', reportProgress?: boolean): Observable<LocationProvidingInfo>;
    public locationProvidingInfoUsingGET(locationId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LocationProvidingInfo>>;
    public locationProvidingInfoUsingGET(locationId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LocationProvidingInfo>>;
    public locationProvidingInfoUsingGET(locationId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (locationId === null || locationId === undefined) {
            throw new Error('Required parameter locationId was null or undefined when calling locationProvidingInfoUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<LocationProvidingInfo>(`${this.basePath}/api/detail-locations/location-providing-info/${encodeURIComponent(String(locationId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * parents
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public parentsUsingGET(observe?: 'body', reportProgress?: boolean): Observable<Array<LocationParent>>;
    public parentsUsingGET(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<LocationParent>>>;
    public parentsUsingGET(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<LocationParent>>>;
    public parentsUsingGET(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<LocationParent>>(`${this.basePath}/api/detail-locations/parents`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
